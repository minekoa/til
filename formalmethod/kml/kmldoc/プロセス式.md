# プロセス式

## イベント

```
event ::= eventName
        | eventName args
        | channel "?" args
        | channel "!" args
        | "(" event ")"
```

イベントは、名前のついたイベントと、チャネル通信の2種類がある

```
<chan> ? <variables> // 受信
<chan> ! <variables> // 送信
```


## プロセス式

```
event_set ::= "{" events "}"
events :=
        | event
        | event "," events

process_expression := process
                    | "(" process_expression ")"
                    | event "→" process_expression
                    | process_expression "\" event_set
                    | process_expression ";" process_expression
                    | process_expression "|||" process_expression
                    | process_expression "|[" event_set "]|" process_expression
                    | "if" cond "then" process_expression "else" process_expression
                    | "STOP"
                    | "SKIP"
```

* 普通のプロセス
    * `P;Q` .. Pの後にQ
    * `P \ {ev1, ev2, ..}` .. イベントの隠蔽
    * `ev -> P` .. ev が置きた後に Pに。
* 並行プロセス
    * `P ||| Q` ..インターリーブ。
    * `P |[ {ev1, ev2, ..} ]| Q` インターフェイス並列
* 特殊
    * `STOP` .. 停止。デッドロック。落ちた。
    * `SKIP` .. 正常終了

### 対応してたか不明のもの

```
                    | process_expression "[]" process_expression
                    | process_expression "|~|" process_expression
```

`[]` (`□`) と `|~|` (`⊓`) は、対応してたか記憶にない.


## チャネル通信

また、ダイアログのような場合はダイアログを並行プロセスにする手も使える。
以下に例を書く。（この例の場合はモードレスダイアログになる）

```
state FooPage (yourName : String) {
    var openDialogButton = Button "ダイアログを開く" True;
    var mesLabel = Label "" True;

    transition openDialogButton_Click
    --> {
        post {
            target state;
            state' = state |[ { okCanResultChan } ]| OkCanDialog "ほげほげしても宜しいですか";
        }
    }

    transition okCanResultChan ? OK
    --> {
        post {
            target mesLabel;
            mesLabel' = { mesLabel | text <- yourName ^ "さん、OKでした" };
        }
    }

    transition okCanResultChan ? Cancel
    --> {
        post {
            target mesLabel;
            mesLabel' = { mesLabel | text <- yourName ^ "さん、Cancelでした" };
        }
    }
}

type OkCan = Ok | Cancel;
chan okCanResultChan OkCan;

state OKCanDialog (msg : String) {
    var msgLbl : Label;
    var okButton     = Button "OK" True;
    var cancelButton = Button "Cancel" True;

    entry {
        post {
            target msgLbl;
            msgLbl = Label msg True;
        }
    }

    transition OkButton_Clicked
    --> {
        post {
            target state;
            state' = (okCanResultChan ! Ok) -> SKIP;
        }
    }

    transition CancelButton_Clicked
    --> {
        post {
            target state;
            state' = (okCanResultChan ! Cancel) -> SKIP;
        }
    }
}
```


解説:

```
state' = state |[ { okCanResultChan } ]| OkCanDialog "ほげほげしても宜しいですか";
```

で今のプロセスと並行して、OkCanDialog のためのプロセスが
起動する。

この二つのプロセスは`okCanResultChan` というチャネルを介してしか
情報のやり取りはできない。

(state変数はこの遷移以降、各プロセスが自分のプロセスを参照する振る舞いになる）

ちなみに、モーダルダイアログにするには

```
state' = ((okCanResultChan ? OkCan) -> state)
       |[ { okCanResultChan } ]|
       OkCanDialog "ほげほげしても宜しいですか";
```

と、ページ側のイベントを okChanResultを受けっとってからでないと
ダメにしておけばいい。
