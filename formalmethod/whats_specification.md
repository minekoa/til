# ソフトウェアの仕様とは？

## ソフトウェアの仕様とは何か

ソフトウェア開発における「仕様」とは、概ねそのソフトウェアが示す振る舞い(Behavior)のことと考えてよい。
振る舞いとは、システム外からの入力（イベント）に対して「どのように振る舞うか」のこと。


## 仕様記述の目的

1. 具体的にはどういうこと？ の解
2. 認識の共有

事前に書く場合は一種のプロトタイピング的な役割も期待される。

また、BDD の場合、仕様を先にテストとして記述することで、設計や実装が仕様を満たしているかを
自動テストできるようにしよう、という試みと言える

形式仕様記述を用いれば、型チェック、モデルチェック など
仕様の正当性の確認の一部を機械にまかせることができる
（しかし形式仕様記述の最大のメリットは、自然言語の曖昧さを排除することである）


## 仕様記述はどうあるべきか

仕様記述は自然言語で抱えることが多いため、
曖昧な自然言語でかかれた「ほのめかし」のような文章も、仕様であると誤解される。

では、仕様記述とはどのようなものか？

> 仕様書とは、システム、すなわち計画された応答のセットが、その境界のす
> ぐ外の世界のイベントにどう反応するかを明確にする文書である。

> どんな仕様書でも、二つの部分から構成される

> 一つは、システムの応答ガイベントにどのように依存するのかを示すポリシーのセット。
> もう一つは、イベントや応答がシステムの境界を超えて行き来するための入出力のセット。

> どんなに複雑なシステムでも、2番目の部分は簡単なはず。入出力はすべて、リスト化できる
> データと制御フローで表すことができる。それぞれに名前か番号をつけられる。
> フロー中のデータ要素数とかなにかで、サイズを決めることができる。それに数えることができる。

（デッドライン ― トム・デマルコ著）

上記引用は、作中で述べられる、仕様かそうでないものかを見分ける良いガイドラインである。

いささか乱暴ではあるが、
すなわち仕様とは、入力に対する出力（振る舞い）定義したリストを必ずもっていると
単純化してしまっても問題はなかろう。


## 仕様記述をする上で注意すべきことは何か

* 曖昧でないこと（具体的であること）
* 網羅的であること

以上の二点を留意すること。
これは自然言語をつかっているとたやすく破られるが、破ったことに気が付きにくいというたちの悪さもある。

例えを出そう。

「イベントAに対して、概ねBの振る舞いをするがときにCとして振る舞うかもしれない」は仕様ではない。
入力に対して、1:1で振る舞いが定まらなければならない。
つまり、異常系も一つの別の「仕様」として入出力のリストに列挙されるべきだ。

note:
正常系のみについてふわっと書かれた文章は、仕様ではなく課題と呼ぶべきである。


もう一点注意すべきは、仕様は実装ではない――設計の粒度や抽象度とは異なる点だ。

例えば、「定義されていない」も明示することも仕様である。
自明であるものは自明であると書いて良い。
この条件をみたすならどのようでも良い・・・が仕様ではありうるので、
この場合は「この条件を満たす何か」とかけば良い

また、設計上の「良いモデリング」は仕様記述上の「良いモデリング」と異なる。

例えば、共通部分のくくりだし（モジュライズ）はあまりすべきでなく、展開して書いたほうが良い。
その場合の展開記述間の不整合を抑止したい場合は、別途「不変条件」を書くようにする。
（仕様の段階でこれをやることは、一種の「早すぎる最適化」であるといえば、腑に落ちるか？）
このため、設計ではアンチパターンとされる SmartUIも、仕様記述ではそうでもない。


## 仕様の書き方（一例）

GUI をシステム外界との境界として持つシステムの仕様を考えよう。
バックエンドもまたシステムに内包されるとすれば、GUI上のイベントのリストを仕様として書くことができる。

GUIをベースして仕様を書く場合は、ページ毎に仕様をかくと書きやすいだろう。

* ページ内変数一覧
* ページ内不変条件
* ページ内で起きうるイベントとそれに対する振る舞いのリスト

の基本3ブロックで書く。

ここにログイン画面の仕様を書いてみよう。

### 1. ページ内変数の一覧

```
ページ内変数:
    ユーザー名インプット   := InputText "" Enable
    パスワードインプット   := InputText "" Enable
    ログインボタン         := Button "ログイン" Enable
    パスワード再設定リンク := Anker "パスワード再設定" Enable
```

画面内のコントロールのモデルを変数として列挙する
また、目には見えない状態（例えば、画面の背後で何かのモデルを組み立てるケースなど）も
ここに変数として書く。


ウィジェットのようなものは、そうではなく単なるレコード（構造体）として捉えると良い。
（いっそメンバへアクセスするドット記法などを導入すると、書きやすい）

形式的に書くならば、それぞれの型を別の場所で定義したほうがよいだろうが、そこはおまかせ。

```
type alias InputText = { value : String, enabled : Enable | Disable }
type alias Button = { label : String, enabled : Enable | Disable }
type alias Anker  = { label : String, enabled : Enable | Disable }
```

また、ここに画面の図案を載せ、変数と関連付けると直感的に理解しやすくなるのでおすすめ。


### 2. ページ内不変条件

また、(ページ内)不変条件は書いておいたほうが読みやすい（間違いに気がつける）

```
不変条件:
    ログインボタン.enabled は ユーザ名インプット.value != "" かつ パスワード名インプット.value != ""
```

これは、「イベントに対する振る舞いリスト」 と重複内容となるが、
イベントリストから不変条件に関する振る舞いを省いてはいけない

（後に 「イベントに対する振る舞いリスト」を読んだ時「あれ？」と思ったときに、
間違いなのかいとしたものかがわかる効果は、侮れない）


### 3. ページ内で起きうるイベントとそれに対する振る舞いのリスト

ページ内で起きうるイベントとそれに対するシステムの振る舞いを列挙する。
結局は、ここが肝である。

単一のイベントについて、事後の振る舞いが変わる時は、ガード（事前条件）により分岐しているはずであるため※、ガードによりかき分ける。
バックエンドの状態による分岐も、事前条件として書く。

| No. | イベント                         | ガード（事前条件）                                                              | 事後条件                                                                                                   |
|-----|----------------------------------|---------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|
| 1   | entry                            |                                                                                 | ユーザ名インプット.value = "" <br> パスワードインプット.value = "" <br>  ログインボタン.enabled は Disable |
| 2   | onInput_ユーザ名インプット str   | パスワードインプット.value != "" && str != ""                                   | ユーザ名インプット.value は str <br> ログインボタン.enabled は Enable                                      |
| 3   | onInput_ユーザ名インプット str   | (otherwise)                                                                     | ユーザ名インプット.value は str <br> ログインボタン.enabled は Disable                                     |
| 4   | onInput_パスワードインプット str | str != "" && ユーザ名インプット.value != ""                                     | パスワードインプット.value は str <br> ログインボタン.enabled は Enable                                    |
| 5   | onInput_パスワードインプット str | (otherwise)                                                                     | パスワードインプット.value は str <br> ログインボタン.enabled は Disable                                   |
| 6   | onClick_ログインボタン           | ユーザ名インプット.value と パスワード名インプット.value がパスワード認証される | 認証チケットを保持 <br> ダッシュボードページに遷移                                                         |
| 7   | onClick_ログインボタン           | otherwise                                                                       | OKダイアログ MSG_LOGIN_FAILURE  を表示<br>                                                                 |
| 8   | onClick_パスワード再設定リンク   |                                                                                 | パスワード再設定画面に遷移                                                                                 |

この場合わけを記述すること自体が「仕様を考える」ということ。

楽に書くコツ:

同じイベントの場合分けは、上の行からマッチを試みマッチできなければ次の条件へ、というルールにすると、
記述量が減るし、「その他」が使えるようになるのでおすすめ。

事前条件や事後条件はある程度「疑似コード風に」書くとよい（メンバへのドットアクセスとか、 != とか使えると書くのがとても楽）

全ての条件は AND または OR でつながるべきだが、自然言語でそれを書くと冗長になるため、
条件は箇条書きで書くこととし、それらは暗黙で AND であるとするのが書きやすい

イベント自体の隠蔽（何も起きない）は、
関連する入力項目の.enabled 属性に依存する暗黙のルールとしておくと
ガードを書かなくてもよくて楽。
（ただ、複合条件とか、わかりにくそう・誤解しそうなところは、その事前条件を明示し事後条件として「何も起きない」を書いておくとよい）

事前条件の組み合わせ爆発が起きるときは、事後条件側に if-else を書くという手もあり。
（多用は厳禁）

#### 手抜きの仕方

おそらく、今回の仕様記述にあたり、一番工数がかかる部分でもある。

本来は手を抜くべきではないが（どうせ機能検証では網羅しなくてはいけない項目である）
手を抜き、仕様記述作業を一旦着地したいのであれば、

* （場合分け自体を諦めるのではなく）事後条件の記述を抽象的な記述にする（「よしなに」 とか「適切なエラーを表示するダイアログを開く」とかして、セルの色を危険色に変えておけばいいだろう）
* 事後条件を書かない（TODOにする）
* 事前条件による場合分けを諦め、諦めたことを明示する（「その他」の下の行「TODO」行を作っておき、自然言語でなにを棚上げしたかを雑に書いておく、「別のイベント」みたいな感じなどと書いておく、調査中と書いておくなど）

の順に手を抜くと良いだろう


#### ページ内変数について

ページ内変数はページを超えて保存しないとし、
ページを超えて保存する状態はアプリケーショングローバルな変数として記述したほうが良い。
この場合、ページに遷移したときは entry イベントが発火するよう書き、そこでローカルに再展開すると良い。

ただし、タブ遷移を基本として、画面の状態を原則キープするアプリケーションの場合、
かえって記述が冗長になってしまうため、前提として「保存する」とするのもありといえばあり。



### (仕様4) 振る舞いの外部定義

長くなるビジネスロジックは用語定義し、別途説明するのがよいだろう

```
パスワード認証 ユーザ名 パスワード
    ユーザ名をIDとするアカウントが DB.account に存在すること
    そのアカウントの保持するハッシュ化パスワードと 入力されたパスワードをハッシュ化した値が一致すること
```

実はそのロジックがなんだかよくわからない場合は

```
パスワード認証 ユーザ名 パスワード
    given
```

などと書いておくだけでもだいぶ良い。

ただし、ソフトウェア設計のような Write Once .. を意図したような積極的な定義に外だしはあまり良くない。
これは仕様記述が、抽象的な振る舞いの曖昧さの落とし穴を事前に察知する行為であるから、という側面のため。

## 非機能要件

これまで書いてきた仕様は、機能要件を満たすものである。

これとは別に、満たすべき性能の指標や、セキュリティの指標などを、「非機能要件」あるいは「非機能要求」と呼び、
上記とは別に自然言語でかく。

IPA のガイドライン「非機能要求グレード」の 6大項目をいかに挙げる（参考）

* 可用性 .. 可用性、耐障害性、災害対策、回復性など
* 性能・拡張性 .. 性能目標値、業務処理料、性能品質保証、リソース拡張性など
* 運用・保守性 .. 通常運用、保守運用、障害時の運用、運用保守の体制など
* 移行性 .. 移行時期や移行対象、移行計画など
* セキュリティ .. セキュリティリスク対応、セキュリティ診断、セキュリティリスク管理、監視、データの秘匿など
* 環境・エコロジー .. (略)

https://www.ipa.go.jp/sec/softwareengineering/reports/20100416.html

ここらへんは、
条件を具体化するのは設計や実装をみてからでないと…というケースも多いので、
目標を文章的に書いてしまったほうが良いケースが多い。

## その他

### ツールは？:

リストなので、ツールはExcelと親和性がよい。
一方でバージョン管理の対象としたい側面もあるため、テキスト言語で書きたい側面もある。

悩ましいところ。

### 外部ライブラリの仕様は書くべきか

書くべき。なぜなら、「そのライブラリの振る舞いが期待される仕様をみたさないためバグとみなされる」が起きうるから。

ただ、現実には（工数的に、あるいは実は細かい振る舞いがわからないなどにより）厳しいことも多々。
陰関数的に書くことで上手いことおさめられれば良いが…、無理なときはスパッと諦めるのもあり。
