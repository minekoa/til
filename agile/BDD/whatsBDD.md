# BDD: ビヘイビア駆動開発 とは？

[ビヘイビア駆動開発 ― ウォーターフォールモデルからのステップ](https://postd.cc/behavior-driven-development/)

を読んだメモ。

これが一番わかりやすい。シンプルで力強く、明快。
素晴らしい。

## ウォーターフォールモデルについて

> 後に「ウォーターフォール」と名付けられたこのモデルは、Winston Royce
> が1970年に発表した、「Managing the development of large software
> systems」（大規模ソフトウェアシステムの開発管理）という論文の中で示
> されたのが最初です

> この論文を通読して、モデルの趣旨を全体的に把握することをお勧めします。
> ほとんどの人は、このモデルが別の文献で引用されている部分だけを読んで、
> 当時最善のものとして提示されたと捉えているのではないでしょうか。とこ
> ろが実際は、論文の著者であるRoyce自身も、このモデルで開発プロセスの
> 最後にテストを実施する点は大きな問題だと認識し

うわ、読んでない。あとで読もう。

http://www-scf.usc.edu/~csci201/lectures/Lecture11/royce1970.pdf

(本文中のリンク先は死んでた）

★

横だけど、「コーディングできない設計者に優秀な設計者はいるか？」の命題に示唆をあたえる

> ウォーターフォールは「一方向への流れ」を連想させる表現ですが、現実で
> は通常、各フェーズ間にフィードバックループが発生します。このモデルは
> 長い間運用されるうちに大幅に改善されました。フィードバックループは最
> 小限に短縮され、プロセス全体の予測精度も向上しました。例えば開発者は
> プログラムを書いている時から、そのプログラムの動作を確認するのにどの
> くらい時間がかかるのかを気にするようになりました。他方、システムの設
> 計段階でも、その設計は実際にプログラミングによる実装および検証が可能
> なのか、その工程のコストはどのくらいかかるのかを調べるようになりまし
> た。

だから（優秀でない場合が多いという直感があるの）か！

★

ウォーターフォールのあの図は OSI参照モデルのように使える気がした。

* System Requirements：システム要件定義
* Software Requirements：ソフトウェア要件定義
* Analysis：要求分析
* Program design：プログラム設計
* Coding：コーディング
* Testing：テスト
* Operations：システム運用

それぞれの Output の名前も定義してあるのかな？

## 「テストファーストプログラミング」と「テスト駆動開発」は違う

「テストファーストプログラミング」と「テスト駆動開発」は違うのか
…無頓着だった

ウォーターフォールのフォールバックが結局開発を遅くしている。
CodingとTestingに着目すると、

```
Waterfall:

 → (Coding) → (Testing) →
      ↑            │
      └──────┘
           Bugs

TestFirst Prgramming:

   ┌→(Testing)─┐
 →│             │→
   └─(Coding) ←┘
```

これがテストファースト。ウォータフォールの Coding -> Testing という流れをサイクルにして
Testと Codingの順番を逆にする。

（また、このサイクルを作ることは別の良い副作用もあった）


では、もう一段上流をみる。

```
(zoom out)

             ┌→(Testing)─┐
 →(Design)→│             │→
      ↑     └─(Coding) ←┘
      └──────┘
          Design is diffiult to test


Test-driven development(TDD):

   ┌→(Testing)─┐
   │             │
 →│          (Coding)→
   │             │
   └─(Design) ←┘
```

Design(プログラム設計) とテストが食い違う。これのフォールバックを高速化するために
ぐるぐるサイクルにDesignも巻き込み、テストを一番前に持ってくる。

これを「テスト駆動開発: TDD」という。ほへー。

## ビヘイビア駆動開発

当然、さらに上流を巻き込むとどうなるの？という発想が出てくる。

```
Test-driven development(TDD):
(zoom out)

               ┌→(Testing)─┐
               │             │
 →(Analysis)→│          (Coding)→
        ↑     │             │
        │     └─(Design) ←┘
        └──────┘
             Not whate we need
```

> 従来ですと、たくさんの機能のリストがあらかじめ用意され開発者へ渡され
> ました。開発者は各フェーズごとに全機能を手がけないと、次のフェーズへ
> 進めませんでした。この方法だと、結果的に、必要のない機能までも実装し
> てしまう場合があります。

うーん。

例えばバックログの管理がイケてない場合におきそうな現象？
（でもユーザーストーリの優先順位付けの話と混同していいのかな）

これスクラムで解決しているのとは別のアプローチなのかな。


```
Behavior-driven development: BDD

      ┌─────┐
      │          ↓
   (Testing)   （Coding)
  ─→↑          ↓
   (Analysys)   (Design)
      ↑          │
      └─────┘

```

> これが、ビヘイビア駆動開発と呼ばれる開発手法です。ステークホルダー
> （ビジネス・オーナー）にとっても開発チームにとっても、時間を節約でき
> る手法です。開発者が早い段階で疑問点を提示することで、開発者自身だけ
> でなくステークホルダーも、自分たちが構築しているものは何か、理解を深
> めやすくなります。ステークホルダーは、結果を得るペースを予測できるで
> しょう。さらに、各機能は小さなチャンク単位で実装されるので、見積もり
> はより正確になります。従って新しい機能も、計画や優先順位づけが容易に
> なるでしょう。

ピンとこない場合のために、プラクティス（例示）を書いたよ！（別ファイル）


## さらにその先


このままスパイラルがどんどん上流に遡るケースとして

> 非常に近いコンセプトとして、リーンスタートアップがあります。

まじかよ。

```
Continuos Delivery: 継続的デリバリ

      ┌─────┐┌────────┐
      │          ↓│                ↓
   (Testing)   （Coding)            (Deployment)
  ─→↑          ↓                  ↓
   (Analysys)   (Design)            (Maintenance)
      ↑          │↑                │
      └─────┘└────────┘
```

> BDDをデプロイや運用まで含んで行うとすると、継続的デリバリーのコンセ
> プトが広がります


理念はわかった
