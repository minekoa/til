# BDDを理解するために「テスト駆動開発／振る舞い駆動開発を始めるための基礎知識」を読んだメモ

（BDDの大枠や理念を理解するには、この記事より WhatsBDD.md のほうがよいです）

## 動機づけ

「chai の should マッチャーを使え」というチーム規約があった。しかしこれがキモい。
(Cプログラミング診断室の「Pascal?」を想像させる）

>```
> path.should.have.lengthOf(6);
> path[0].should.be.equal('');
> path[1].should.be.equal('tutorial');
> path[2].should.be.equal('sample');
> path[3].should.be.equal(familyId);
> path[4].should.be.equal(regionId);
> path[5].should.match(/^[a-zA-Z0-9]{24}$/);
>```

`be`とか`a`とか、意味のないメソッドをチェーンさせて自然言語風にするライブラリ。

公式リファレンス

[Expect/Should | Achai Assertion Library](https://www.chaijs.com/api/bdd/)

には

> # BDD
> BDDスタイルは `expect`と` should`です。どちらも同じ アサーションを構築する
> チェーン可能な言語ですが、アサーションが最初に構築される方法が異なります。
> 比較のために[スタイルガイド](https://www.chaijs.com/guide/styles/)をチェックしてください

なんて書いてある

こんなことをさせる原動力となった BDD なるものを調べる、という同期。
（TDDの派生くらいの認識しかなかった）

## まずは Wikipedia

[ビヘイビア駆動開発 | Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%93%E3%83%98%E3%82%A4%E3%83%93%E3%82%A2%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA)

うん？

> テスト駆動開発で記述されるテストケースは、作成したプログラムの動作が
> 正しいかどうかを検証するために行う「テスト」である。テストであるとい
> う点は同一であるが、加えて、これから作成しようとするプログラムに期待
> される「振る舞い」や「制約条件」、つまり「要求仕様」に近い形で、自然
> 言語を併記しながらテストコードを記述する。テストフレームワークのメソッ
> ド名も自然言語（英語など）に近い形をとっている。

うん？

> テストコードの可読性があがる上、テストコードが要求仕様となりうる。要
> 求仕様からテストコードを起こす際も、スムーズにコードに移行しやすい。

うん？
要求仕様キターッ

> BDDではスペック（仕様）とテストは限りなく近い物である。従って、テス
> ト駆動開発における「テストファースト」は、BDDにおいては「スペックファー
> スト」となり、スペックを作ってから実装するという、より自然な形でのプ
> ログラム製作を実現している。

形式仕様界隈の人から全力で怒られそうな気がするが、どうなんだろう。

## テスト駆動開発／振る舞い駆動開発を始めるための基礎知識

Wikipediaではわかった気になるだけなので @ITの記事を

[テスト駆動開発／振る舞い駆動開発を始めるための基礎知識 (1/3)](https://www.atmarkit.co.jp/ait/articles/1403/05/news035.html)


目次より

> * 振る舞い駆動開発（BDD）とは
>   * コードレベルのBDD
> ユーザーレベルのBDD
> BDDで重視される2つの考え方
> 【1】「Tests as Documentation」（ドキュメントとしてのテスト）
> 【2】「Specification by Example」（例示による仕様）

うーん、ちょっと前に「テストを仕様という奴らがいる」的に突っ込みに来た
界隈に親しいと怖い目次だ。

★

> 「[振る舞い駆動開発](http://dannorth.net/introducing-bdd/)」とは、
> TDDに触発されてDan North氏により提唱され発展した手法です。

> * テストを「振る舞い」（機能的な外部仕様）の記述に特化させる
> * ユーザーの要求やアーキテクチャの設計仕様といった、より上位のインプットとTDDのテストにつながりを持たせる

この時点で「この現場 BDD してないからもう読まなくていいんじゃね」「BDDスタイルassert採用する理由ないんじゃね？」・・的な考えがよぎったが
興味があるのでこのまま読み進める

> ちなみに今日のBDDは、いろいろな意味や定義で使われる用語になってしまっています。

きな臭い。

★

どうもテストを非プログラマにも読めるようにしないとだめらしい。
…だったら、これ、日本でやるには日本語にすべきじゃん。
（プログラミング言語読め、と英語で仕様読め、は障壁としておなじよ）

★


> BDDでは、テストの記述において「Tests as Documentation」
> 「Specification by Example」という2つの考え方が重視されます。

ふむん。

> 「Tests as Documentation」はテストをドキュメントとして扱うアプローチ
> です。テストの可読性を上げ、テスト対象の振る舞いを分かりやすく記述す
> ることにより、テストをテスト対象の詳細仕様書のように扱えるようにしま
> す。これはテスト対象の保守に活用されます。

BDD、真面目にやるなら ADTの仕様記述と1:1になるようなテストを書くことになか？
すたっく、すたっくかぁ…。メイヤー先生、スタック定義しますよ！

> 「Specification by Example」は、例示による要求や仕様の記述を活用する
> ための包括的な考え方です。例示を使って要求獲得や要求仕様化を行うこと
> で、ユーザーとのコラボレーションや変化への対応、ユーザー要求と設計と
> の関連付けを促進することを目的としています。

ふむん。これ、ユースケースシナリオをこれで書いちゃう感じになる？
なるのかなぁ。だめなのかなぁ。

★

ちょっと戻る。

> ユーザーレベルのBDDは、受け入れテストやEnd-To-Endのシステムテストと
> いったテストレベルを扱う、ユーザー要求や外部仕様の実現を駆動するBDD
> です。テストファーストの一種ですが、

> ユーザーレベルのBDDでは、テストの記述に特定のフォーマットに合わせる
> セミフォーマルなアプローチが好まれます。
>
> 例えばアジャイルでは、しばしば「ユーザーストーリー」の形式でテストを
> 記述します。テストの拡張性を重視する場合は「データ駆動テスト」や「キー
> ワード駆動テスト」の構造をテストの記述に導入する場合もあります。

ユーザーストーリの形式ってなに？

https://agile.esm.co.jp/services/agile/process.html

> ユーザーストーリーはユーザーが実現したいことやユーザーにとって価値があることを簡潔にまとめた文章です。

[簡単！楽しい！5分でわかるユーザーストーリーマッピング(User Story Mapping)|Qiita](https://qiita.com/Koki_jp/items/6aebc73bedd0a932dcb8)

> 電子メール管理システムの場合
>
> 1.ユーザは電子メールを検索できる。
> 2.ユーザは電子メールをファイリングできる。
> 3.ユーザは電子メールをキーワードで検索できる。
> 4.ユーザは電子メールを移動できる。
> 5.ユーザはサブフォルダを作ることが出来る。なぜならそこに電子メールを移動させたいからだ。

★

こんな感じか。

* 特権ユーザーはサンプルデータを生成できる
* 特権ユーザーは生成したサンプルデータを○○で検索できる
* 特権ユーザーは生成したサンプルデータの一覧を閲覧できる
* 特権ユーザーは生成したサンプルデータを○○で削除できる
* 生成したサンプルデータは特権ユーザー以外から守られる

これをどうテストに落とせばいいんだ？

★

ユーザーストーリは仕様じゃないからなぁ。

★

読みたい

* [ビヘイビア駆動開発 ― ウォーターフォールモデルからのステップ](https://postd.cc/behavior-driven-development/)
* [BDDの話をしよう | やさしいデスマーチ](http://d.hatena.ne.jp/shuji_w6e/20101226/1293290205)

## 「アウトサイドインTDD」「インサイドアウトTDD」

その前に、「アウトサイドインTDD」「インサイドアウトTDD」がよくわからないので読む。

> ## インサイドアウトTDDとは
>
> プログラミング手法としてのTDDでは、クラスや関数といったコンポーネン
> ト単位の粒度でテストファーストのサイクルを回していくスタイルが一般的
> です。そのスタイルでは、以下のようなアプローチがしばしば採られること
> になります（このアプローチは、後述するアウトサイドインTDDと対比して、
> 「インサイドアウトTDD」と呼ばれます）。
>
> * TDDのテストファーストのサイクルで、コンポーネントごとに設計を考えていく
> * 各コンポーネントを積み上げながら、インクリメンタルに全体設計を構築していく
>
> このTDDでありがちなインサイドアウトのアプローチについては、Mockオブ
> ジェクトの使用の手間が省ける、プログラマー主体の柔軟な設計の作り込み
> に対応できるといったメリットを持っています。

* プログラミング手法としてのTDD
    * 一般的なスタイル
        * テスタファーストのサイクルの単位 = コンポーネント単位
            * コンポーネント is {クラス, 関数, ...}
        * このスタイルでのアプローチ
            * サイクル単位でコンポーネントごとの設計を考える
            * 各コンポーネントを積み上げながら、インクリメンタルに全体設計を構築
        * named: インサイドアウトTDD
        * メリット
            * Mockオブジェクトの使用の手間が省ける
            * プログラマー主体の柔軟な設計の作り込みに対応できる
        * プロブレム
            * より大きな設計の全体整合を保証しにくくなること
                * より大きな設計 is {アーキテクチャ設計, コンポーネントセットの設計, ...}
            * 上位のインプットとTDDのプログラミングが断絶する
                * 上位のインプット is {ユーザー要求, アーキテクチャ設計, ...}
        * プロブレムより生ずるイシュー
            * 設計品質の問題で開発の手戻りコストや保守コストを悪化させる
            * ユーザーへの価値の実現というテストファーストの当初の目的を欠落させる
    * アナザースタイル (前述のイシューへのソリューション)
        * named: アウトサイドインTDD
        * このスタイルでのアプローチ
            * 1. アーキテクチャなどの全体構造の設計を行う
                * この時点で コンポーネントの振る舞いを明確化
            * 2. モック(Mock)で全体を構築する
                * 未実装状態でも全体設計を仮想的にテストで動かせる状態に.
            * 3. TDDでモックオブジェクトを本物のオブジェクトに置き換えていく
        * 重視する価値観
            * TDDでの実装対象はどのような振る舞いをするべきかという要求を明確化する
            * それをテストで記述し、そのテストで開発を駆動させていくことです
        * イシュー
            * モックを多用するため、TDDのテンポを阻害する
                * 必要: モックやエクスペクテーションを軽快に記述できるクライブラリ・開発環境
            * アジャイルじゃなくなる(ウォーターフォール的なアプローチになりがち)
                * ウォータフォール is [厳格に要求仕様化を行い、厳格に基本設計・詳細設計を行って、詳細仕様の通りにTDDを進める]
                * 必要: 変化に対応でき、品質の高い設計を実現する技量


理解した(スタイル

★

イシュー。だめじゃねぇか

> アウトサイドインTDDでカバーできないさらに上位のテストレベルとのつなが
> りを明確化するために、「テストファーストのダブルループ」というアプロー
> チが考案されました

テストは仕様ではない、という現実をみとめられながゆえの
こじらせに見えるなぁ

★

> これは「End-To-Endテスト」（システムテスト）の自動化環境と、単体テス
> トの自動化環境を構築し、両方でテストファーストを回していくアプローチ
> です。具体的には、以下の手順を採ります。
>
> * End-To-Endテストで失敗するテストを書く。なお未実装のコンポーネント
>   がある場合は、ウォーキングスケルトン（モックなどを使って実行可能に
>   したアーキテクチャのスケルトン）を構築して最低限のテストだけ実行可
>   能にする
>
> * End-To-Endテストを成功させるように、アウトサイドインTDDでプロダク
>   トコードを実装する


★

> 一例として、前述のアウトサイドインTDDもBDDの一種に該当します。なお
> BDDはTDDから生まれた手法ではあるものの、TDDで欠落しがちになったアジャ
> イルのテストファーストの目的・原則に立ち返るという、原点回帰の方向性
> も備えています。

よし、BDDに戻ってきた。
